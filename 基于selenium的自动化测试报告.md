>基于selenium的自动化测试     

按照以下顺序进行介绍

- [ ] 软件测试
- [ ] 自动化软件测试
- [ ] selenium

> 软件测试

- 软件产品的组成部分
  软件产品的组成清单如下，由此可知**软件产品不仅限于代码**。
  帮助文件、样本和示例、产品支持信息、错误信息、安装、用户手册、标签和帖子、图标和标识、广告和宣传材料、说明文件.

- 软件开发模式
  从最初构思到公开发行软件产品的过程称为软件开发模式
  常用的软件开发模式有四种： 大棒式、 边写边改式、流水式、螺旋式。其中螺旋式有利于软件测试，因为软件测试员可以尽早参与到产品的开发过程，有利于缺陷的及时发现。螺旋模式的主要思想是开始不必定义所有详细细节。从小开始，定义重要功能，努力实现，接受客户反馈，然后进入下一阶段。重复上述过程，直到获得最终产品。

- 软件测试的一些特点

  - 完全测试程序是不可能的
  - 软件测试是有风险的行为 如果不去测试所有的情况，那就是选择了风险
  - 测试无法显示潜伏的软件缺陷
  - 找到的软件缺陷越多，说明软件缺陷越多。
  - 杀虫剂现象 经常使用某种农药，导致害虫最后对该种农药具有抵抗力，农药发挥不了作用。软件测试也类似，为了克服杀虫剂怪事，软件测试元必须不断编写不通的新测试程序用于测试

- 软件测试方法

|      | 静态           | 动态         |
| ---- | -------------- | ------------ |
| 黑盒 | 检查产品说明书 | 动态黑盒测试 |
| 白盒 | 检查代码       | 动态白盒测试 |

- 动态黑盒测试
  不深入代码细节的软件测试方法称为动态黑盒测试，程序是运行的，因此是动态的，测试员不详细了解代码细节，只需要知道输入什么得到什么，因此是黑盒的。为了进行黑盒测试，需要定义测试案例。

- 软件测试的基本方法 – 通过测试和失败测试
  通过测试用于确认软件至少能做什么而不会考验其能力。
  失败测试是纯粹为了破坏软件而设计和执行的测试案例。

- 等价分配 –分步骤的把过多的测试案例减小到同样有效的小范围的方法。

- 通过测试

   - 数据测试
      对数据进行软件测试，就是检查用户输入信息，检查计算结果是否正确。
      但是即使简单的程序要处理的数据量也可能巨大。如计算器，处理逻辑较为简单但是却可以处理巨大的数据量。所以需要根据以下主要原则进行等价分配，以合理减少测试案例：边界条件、次边界条件、空值和无效值。

      - 边界条件
        程序可能在处理大量中间数据时都是对的但是可能在边界处出现错误，然而只测试边界条件往往不够充分，较好的做法是测试边界两边-刚好是边界以及刚好超出边界。
      - 次边界条件
        上述普通边界比较容易找到，有些边界条件出现在程序内部，最终用户可能看不到，但是仍有必要进行软件测试，这种边界条件称为次边界条件或内部边界条件。
      - 空值
        用户根本没有输入，好的程序应该返回提示用户的信息。
      - 无效值
        无效值是一类垃圾数据，是失败测试的对象，现实中总有用户不会遵照程序的要求输入，这就要求需要处理用户无效输入，而不让程序崩溃。

    - 状态测试
     通过建立软件的`状态转换图`，使用等价分配方法减少要测试的状态及转换的数量，在保证每种状态被访问一次的基础上，尽量测试最常见的和最不常见的分支转换。
      然后讨论`失败状态测试`
      和通过测试相反，失败状态测试通过竞争条件、压迫和`重负`的方法，不断给程序施压，以造成程序崩溃。其中，重复测试最简单的操作是不停的启动关闭程序，或者反复执行某一个操作，进行这种重复测试主要是看是否具有`内存泄漏`问题。如果计算机内存在操作结束时没有完全释放，经过若干次的重复，就会暴露这个问题。

- 动态白盒测试
  动态白盒测试包括直接测试底层功能、以完整程序测试样例、从软件中读取信息以确定测试结果是否正确，或者强制赋值进入错误状态，测试软件状态。
  其中使用代码分段建立和测试的方法，即单元测试和集成测试，能比较高效的完成测试。在底层进行的测试称为单元测试或模块测试，等单元测试完成，将单元集成以后，对模块组进行测试称为集成测试。

除了上述已经提到的测试，还有一些其他的测试需求，如硬件测试、兼容测试、外国语言测试、易用性测试等，此处不再赘述。

- 最后再来讲一下网站测试：
  在测试网站时，首先应该建立状态表。将网页视作结点，超链接视作边，构建状态表。然后检查各个网页之间的连通性测试，并测试浏览器兼容性、性能、html标准符合成都和拼写。




>自动化软件测试

从对软件测试的自动化程度可以分为手工测试和自动化测试。

- 手工测试 
  由测试人员一个一个地去执行测试用例，手动输入参数并查看返回结果是否符合预期输出。


- 自动化测试
  将手工输入的过程经过一定的组织后转化为一种自动的机器行为。自动化测试可以分为：功能自动化测试和性能自动化测试。

  - 功能自动化测试：着重于对软件的功能进行测试，并验证结果是否正确。
  - 性能自动化测试：通过工具来模拟需要测试的对应环境，以测试软件的处理性能。


- 分层的自动化测试
  测试金字塔的概念由Mike Cohn首次提出，他的基本观点是：应该进行更多的单元测试，而不仅仅是通过用户界面运行的高层的端到端的测试.。在传统自动化测试基础上，提出了“分层”的概念。
  传统的自动化测试工具可以理解为基于产品UI的的自动化，是将动态黑盒测试自动化的过程。
  ![在这里插入图片描述](https://github.com/jackcily/SoftSecurity_job/raw/master/img/3.jpg)


	- 单元自动化测试
	单元测试是开发者必须完成的任务，证实该单元能完成期望的任务而不出错是开发者的责任。单元测试的主要目的包括：验证逻辑能工作、验证所有必须的逻辑都存在。
在编码过程中，单元测试可以是函数、子例程、语法单元。除此之外，单元测试也可以被认为是小范围测试、程序片段测试、模块测试等。
在软件的开发过程中，发现缺陷的修复代价随时间增长呈指数式增长。因此必须对单元测试给予高优先级，避免将有错误的代码提供给软件进行其他更高层次的工作。单元测试中发现的问题必须被修复，并重新进行回归测试。
规范的进行单元测试需要借助单元测试框架。几乎所有主流语言都有其相应的单元测试框架，如python语言的unittest。

	- 接口自动化测试
	Web应用的接口自动化测试大体可以分为模块接口测试和web接口测试。
	
		- 模块接口测试主要测试模块之间的调用与返回，主要强调对一个类方法或函数的测试，测试工具类似于单元测试工具。
		- Web接口测试包括服务器接口测试和外部接口测试。前者指浏览器和服务器之间的接口，用户操作作用于前端上，通过调用后端接口获取需要的数据。后者指调用的接口由第三方提供（既不是客户端也不是服务器）。
	
	- UI自动化测试
	UI 层是用户直接进行交互的入口，所有功能需要通过Ui 展示给用户，所以测试工作主要集中在该层，目前存在的自动化测试工具有 UFT、Robot framework、selenium等。除了UI所展示的功能，前端同样需要进行测试。
从分层自动化测试金字塔可以看出，UI 测试位于顶部，这说明UI测试应该投入较少的自动化测试，原因是UI是多变的，需要投入较多的精力进行自动化测试，并且如果只关注UI 层，很难保证产品的最终质量，因此需要根据项目实际情况引入UI自动化测试。


- 什么样的项目适合自动化测试？

  - 软件需求变动不频繁
  - 比较频繁的回归测试
  - 需要在多平台上运行的相同测试案例、组合遍历型的测试、大量的重复任务。
    该条规则的本质就是此条件会导致自动化测试脚本的重复使用，可以降低自动化测试的开发成本。
  - 软件维护周期长、进度压力不大。






>selenium

Selenium是一个用于web应用程序测试的工具，支持多平台、多浏览器、多开发语言进行自动化测试，此处选用selenium进行自动化测试的尝试。

Selenium现在经历了三个版本的迭代，selenium1.0、 selenium2.0、selenium3.0。selenium不是一个单独的软件，而是由一些插件、函数库组成的工具集，每个部分都有各自的特点以及适合的应用场景。

**selenium1.0**的组成如下：
![4](https://github.com/jackcily/SoftSecurity_job/raw/master/img/4.png)

- selenium IDE
  官方给出的selenium IDE的定位如下：
  快速的创建bug重现脚本，在测试人员测试过程中，发现bug以后可以通过将IDE重现的步骤录制下来，以帮助开发人员更容易的重现之前的bug。
  IDE录制的脚本可以导出为多种语言的脚本，有助于帮助软件测试员更加快速的开发脚本。


- Selenium Grid
  Selenium Grid 是一款帮助软件测试员进行进行分布式测试的自动化工具。利用Selenium Grid 可以很方便的在多台机器上和异构环境中运行测试样例。

- Selenium RC
  Selenium RC 是selenium1.0家族的核心部分，通过Selenium RC的服务器，运用各种语言的自动化脚本，可以间接访问应用，从而达到测试目的。Selenium RC分为client library和 selenium server 。client library用于编写自动化测试脚本。Selenium server 用于执行自动化测试脚本，可以控制浏览器的各种行为。其中，selenium server又包括三个部分 lancher 、http proxy、 core。Lancher用于启动浏览器，http proxy 充当浏览器的代理，Core就是一堆js函数，core通过js函数实现对浏览器行为的控制。

**Selenium2.0**

Selenium2.0 和selenium1.0相比就是加入了webdriver。需要注意的是，selenium2.0主推webdriver，webdriver相当于RC的代替。为了保持向下兼容，selenium2.0 同时支持webdriver和RC。相比于RC，webdriver的改进之处有通过原生浏览器扩展直接控制浏览器，和浏览器的集成更加密集，因此可以创建更高级的测试案例，除此之外，webdriver还可以进行系统级别的调用，实现更高级的测试。

**Selenium3.0**
最大的变化就是selenium1.0 的core函数将被废弃，重点将转移到webdriver API上，在过去的几年中，已经逐渐从core过渡到webdriver API。在selenium3.0中，RC的原始实现已经被删除，取而代之的是webdriver API。
除此之外，geckodriver提供对更高版本的firefox的支持，它基于不断发展的W3C WebDriver规范，并使用该规范中的有线协议。原始selenium仅支持firefox47.0.1或者更低版本。还有一些变化是Grid中的稳定修复，所有Grid节点现在都可以提供帮助已更新至最新版本的HtmlUnitDriver重新启用独立服务器的日志收集。


- Webdriver
  Webdriver属于selenium体系中设计出来操作浏览器的一套API，站在编程语言的角度，webdriver相当于一个函数库。
  首先查看webdriver提供的八种元素定位方法，在python语言中，对应的方法如下:

  ```
  find_element_by_id
  find_element_by_name
  find_element_by_xpath
  find_element_by_link_text
  find_element_by_tag_name
  find_element_by_class_name
  find_element_by_css_selector
  find_element_by_partial_link_text
  
  ```
  以下是一个通过id定位百度搜索框并输入搜索关键词的实例
  ![6](https://github.com/jackcily/SoftSecurity_job/raw/master/img/6.PNG)


	- Xpath
		Xpath是用于xml文档定位元素的一种语言，由于html可以看做xml的一种，因此可以使用xpath在html中进行定位.
		
		- 绝对路径定位
		Xpath有很多定位方法，最简单的就是直接通过绝对路径进行定位，对于xpath来说，就是利用标签名的层级关系来定位元素的绝对路径，如果一个层级的下面具有多个相同的标签就使用编号进行区分，例如以下的一个绝对路径中 span[3] 就代表当前层级下的第三个span标签。
`Xpath = “/html/body/div/span[3]/a”`

		- 利用元素属性进行定位
		除了使用元素的绝对值直接定位，还可以使用元素的属性值定位元素。比如以下的例子是用于定位百度首页中搜索输入框的位置，其中 input表示元素的标签名 [@id =’kw’]表示这个元素的 id值为 kw，通过标签名称和id属性定位某个确定的元素。`Xpath = “//input[@id=”kw”]”`
	
		- 层级属性相结合进行定位
		如果一个元素自身没有可以用于直接标志自身的属性值，可以使用父级元素的属性值用来辅助定位元素。比如以下的例子是用于定位百度首页中搜索输入框的位置。使用这个xpath首选会匹配class =“test”的span标签，匹配成功以后然后在该标签下匹配id =“kw”的input标签。类似的，如果父元素属性仍不能唯一定位元素，可以继续向上查找父标签。直到唯一定位某个元素。`Xpath =” //span[@class=”test“//input[@id=”kw”“`
	
		- 使用逻辑运算符进行定位
		 如果一个属性不能唯一的区分一个元素，可以尝试使用逻辑运算符连接的多个属性来查找运算符。比如以下的例子是用于定位百度首页中搜索输入框的位置。在样例中，使用逻辑运算符 and连接input标签的两个属性，只有同时满足这两个属性的input标才能被成功匹配。
`Xpath =  “//input[@id=”kw” and class = “su”]”`

	-  Css定位
	Css是一种用于修饰html和xml文档的语言，css使用选择器为页面元素绑定属性，webdriver可以利用这些选择器进行另外的定位策略。Css的使用较为灵活，一般速度要比xpath快。
此处css选择器的语法展示略过。
`find_element_by_css_selector`
函数用于css语言定位元素，例如以下的例子 .表示通过class test定位元素。
`find_element_by_css_selector(“.test”)`
但是仅仅使用标签进行定位有时候并不能唯一定位某个元素，所以可以像xpath一样，使用父标签进行辅助定位。比如以下的例子就表示了符合条件的a吗 标签父标签是span。
`find_element_by_css_selector(“span > a”)`
同样的，也可以使用属性进行定位，或者将以上的项进行组合使用。


	以上可以看出，xpath和css都具有强大的定位能力，具体使用哪种可自行选择。
	Webdriver的主要提供操作页面上的各种元素，但是也提供了操作浏览器的一些方法，如控制浏览器的大小，以及浏览器的前进后退等等。在使用webdriver模拟操作元素的时候，需要注意的是，由于很多web程序使用ajax技术，所以浏览器加载网页的时候，页面的元素不一定是同时加载完成的，所以有时候需要设置等待时间以等待元素加载完成。Webdriver提供了两种类型的等待，显示等待和隐式等待。前者是在等待某个条件成立后继续执行，后者是直接等待一定的时长然后继续执行。在web应用中，经常会遇见表单嵌套的应用，但是webdriver只能在一个页面上对与元素进行识别，对于表单内嵌的元素无法直接进行定位，这时候就需要先切换到对应的表单内嵌页面中才能继续执行对应操作。同样的，有时候页面会弹出新窗口，这时候主机需要在多个窗口之间进行切换。有时候需要验证浏览器中的cookie是否符合要求，webdriver同样提供了操作cookie的相关方法，比如读取、添加、删除等操作。
	- Webdriver的工作原理
	1.	首先webdriver启动浏览器，并绑定到指定端口。启动的浏览器作为server。
	2.	Client端通过发送请求给server的监听端口，向server请求数据，或者请求的操作。
	3.	Server依赖原生的浏览器组件转化client端的调用或者请求。


- Selenium IDE

直接在官网下载安装selenium IDE。

- 下面尝试selenium的录制脚本的功能。
  首先打开selenium IDE，将录制按钮设置为启动状态，然后在浏览器中访问百度首页，进行搜索点击，结束录制，此时可以看到已经录制成功截图如下
  ![1](https://github.com/jackcily/SoftSecurity_job/raw/master/img/1.PNG)
  录制完成的脚本，还可以进行编辑以更好的适应需求。命令由command、target、value三部分组成、可以对这三部分命令进行编辑。可以进行插入命令、插入注释、移动命令、定位辅助等脚本命令的手动编辑。
  但是仅仅能自动执行的脚本还不能叫测试用例，真正的测试用例需要有断言或者验证，一定要有测试结果和预期结果的比对，并判断是否通过该测试样例。可以通过插入命令的方式在任何位置插入断言或者验证。所以我们在写自动化测试样例以后，一定要注意对测试结果的验证。

  - 断言
    如果使用断言，测试用例将会在断言失败后停止运行，这样可以知道测试程序没有正确执行，有利于直截了当的看到检查是否通过。但是，这样也会导致一个问题，如果某个命令失败，后边的命令不会继续执行，导致效率很低，无法最大情况的检查所有结果状态。
  - 验证
    与断言相比，当验证命令执行失败的时候，并不会直接停止执行，无论是否发现缺陷。这样的好处是一次就一定能把所有命令运行一遍，坏处是需要进行进一步的检查，才能最终确定软件是否出问题。
    具体使用哪种测试指令，可以根据需求自行决定。在selenium3.0中可以使用诸如if、else之类的控制语句对测试用例进行控制。

- Selenium Grid
  Grid是用于进行分布式测试的工具，整个结构由一个hub主节点和若干个node代理节点共同构成。其中，hub用于管理各个节点的注册和状态信息，并接受远程客户端的脚本执行语句，然后将客户端的请求命令转发给代理节点来执行。这种间接转发的执行方式和直接调用selenium server执行的结果是一样的，只不过调用过程有所区别。需同时启动一个hub和至少一个node。
  当测试用例需要在多种环境进行验证时，可以通过Selenium Grid在多个节点上并行的验证测试用例进而缩短测试总耗时。Grid会根据用例指定的平台配置信息把用例转发给对应的测试代理。Grid收到用户端的测试样例，根据要求和节点的注册信息自动匹配符合条件的测试代理，并转发对应的测试需求。


- Webdriver驱动
  打开selenium包中的webdriver/init.py文件，如下图，发现selenium统一导入了各个浏览器的驱动，它对不同驱动的路径做了简化，并且将不同目录下的webdriver类重命名为相应的浏览器，所以在调用不同浏览器的驱动时就简化了层级。
  ![2](https://github.com/jackcily/SoftSecurity_job/raw/master/img/2.PNG)
- Unittest单元测试框架
  使用框架的好处有以下几个:

  - 更好的进行用例的组织执行：当测试用例的数量比较多的时候，可以使用该框架进行用例的规范和维护。
  - 提供更加丰富的的比较方法：单元测试框架可以提供丰富的断言方法，用于比较测试产生结果和待测结果。
  - 提供丰富的日志：在测试用例执行失败的时候，使用该框架可以获得更清晰明了的结果。当执行完所有测试结果，该测试框架可以进行更好的宏观统计，如总执行时间、总成功案例数等等。

  从该单元测试框架的这些特性看，该测试框架也很适用于web自动化的开发与执行。
  为了让测试代码更容易维护和编写，最好遵照一定的规范进行测试样例的编写，这正是该单元测试框架的核心思想，通过使用unittest框架编写的测试用例，符合一定的规范，有利于更好的维护测试用例。


	在unittest文档中有4个比较重要的概念，分别是 text fixture 、test case、test suite 、test runner。

  - Test case：就是测试用例，一个完整的测试用例包括测试前环境的搭建，测试功能代码，测试完成以后环境的清理。
  - Test suite：就是多个测试用例的有机组合。一个功能的测试往往需要多个测试用例，这时候就会产生测试用例的集合，test suite 就是这个意思。
      - Test runner：测试的执行。
       - Text fixture： 对一个测试用例环境的搭建和清除工作，就是fixture，通过清除工作为下一个测试用例留下一个干净的环境。


- Page object 设计模式
  该设计模式是selenium自动化测试的最佳测试模式之一，强调测试逻辑数据驱动之间相互分离，page object是一种测试设计模式，主要是将每一个页面设计成一个类，类中包含页面需要测试的各种元素，如按钮输入框等等，这样在selenium测试页面中可以通过调用页面类获取需要测试的元素，相当于对测试元素进行集中管理，可以更好地应对元素变化。

  具体做法为：
  1创建页面类，在页面的类中编写页面需要的操作方法。
  2在测试用例的类中，传递页面的类和已经实例化的webdriver对象，以进行操作。如调用页面类的封装函数。



- [ ] 参考资料

- [基于 SELENIUM 的自动化测试架构](https://blog.csdn.net/lintyleo/article/details/79362367)